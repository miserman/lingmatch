% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/lingmatch.R
\name{lingmatch}
\alias{lingmatch}
\title{Linguistic Matching and Accommodation}
\usage{
lingmatch(x, comp = mean, data = NULL, group = NULL, ...,
  comp.data = NULL, comp.group = NULL, order = NULL, drop = TRUE,
  all.levels = TRUE, type = "lsm")
}
\arguments{
\item{x}{Texts to be compared; a vector, document-term matrix (dtm; with terms as column names),
or path to a file (.txt or .csv, with texts separated by one or more lines/rows).}

\item{comp}{Defines the comparison to be made:
\itemize{
  \item If a function, this will be applied to \code{x} within each group (overall if there is
    no group; i.e., \code{apply(x,2,comp)}; e.g., \code{comp = mean} would compare each text to
    the mean profile of its group.)
  \item If a character with a length of 1 and no spaces, if it partially matches one of
    \code{lsm_profiles}'s rownames, that row will be used as the comparison; if it partially
    matches \code{'auto'}, the highest correlating \code{lsm_profiles} row will be used; if it
    partially matches \code{'pairwise'}, each text will be compared to one another.
  \item If a character vector, this will be processed in the same way as \code{x}.
  \item If a vector, either of the same length as \code{x} has rows and logical or factor-like
    (having  n levels < length), or a numeric range or logical of length less than \code{nrow(x)}
    , this will be used to select a subset of
    \code{x} (e.g., \code{comp = 1:10} would treat the first 10 rows of x as the comparison;
    \code{comp = type=='prompt'} would make a logical vector identifying prompts, assuming
    "type" was the name of a column in \code{data}, or a variable in the global environment,
    and the value "prompt" marked the prompts).
  \item If a matrix-like object (having multiple rows and columns), this will be treated as a
    sort of dtm, assuming there are common column names between \code{x} and \code{comp} (e.g.,
    if you had prompt and response texts that were already processed separately).
}}

\item{data}{A matrix-like object as a reference for column names, if variables are refereed to in
other arguments (e.g., \code{lingmatch(text, data=data)} would be the same as
\code{lingmatch(data$text)}.}

\item{group}{A logical or factor-like vector the same length as \code{nrow(x)}, used to defined
groups.}

\item{...}{Passes arguments to \code{\link{lma_dtm}}, \code{\link{lma_weight}},
\code{\link{lma_lspace}}, and/or \code{\link{lma_termcat}}, depending on \code{x} and
\code{comp}.}

\item{comp.data}{A matrix-like object as a reference to \code{comp} variables.}

\item{comp.group}{The Column name of the grouping variable(s) in \code{comp.data}; if
\code{group} contains references to column names, and \code{comp.group} is not specified,
\code{group} variables will be looked for in \code{comp.data}.}

\item{order}{A numeric vector the same length as \code{nrow(x)} indicating the order of the
texts and grouping variables if the type of comparison is sequential. Only necessary if the
texts are not already ordered as desired.}

\item{drop}{logical; if \code{FALSE}, columns with a sum of 0 are retained.}

\item{all.levels}{logical; if \code{FALSE}, multiple groups are combined. See the Grouping and
Comparisons section.}

\item{type}{A character at least partially matching 'lsm' or 'lsa'; applies default settings
alighning with the standard calculations of each type:
\tabular{ll}{
  LSM \tab \code{lingmatch(text, weight='count', dict=lma_dict(1:9), metric='canberra')}\cr
  LSA \tab \code{lingmatch(text, weight='tfidf', space='internal', metric='cosine')}\cr
}}
}
\description{
Offers a variety of methods to assess linguistic matching or accommodation, where \emph{matching}
is general similarity (sometimes called \emph{homophily}), and \emph{accomodation} is some form
of conditional similarity (accounting for some base rate or precedent; sometimes called
\emph{alignment}).
}
\details{
There are a great many points of decision in the assessment of linguistic similarity and/or
accomodation, partly inherited from the great many point of decision inherent in the numerical
representation of language. Two general types of matching are implemented here as sets of
defaults: Language/Linguistic Style Matching (LSM; Niederhoffer & Pennebaker, 2002; Ireland &
Pennebaker, 2010), and Latent Semantic Analysis/Similarity (LSA; Landauer & Dumais, 1997;
Babcock, Ta, & Ickes, 2014). See the \code{type} argument for specifics.
}
\section{Grouping and Comparisons}{

Defining groups and comparisons can sometimes be a bit complicated, and requires dataset
specific knowledge, so it can't always (readily) be done automatically. Variables entered in the
\code{group} argument are treated differently depending on their position and other arguments:

\describe{
  \item{Splitting}{By default, groups are treated as if they define separate chunks of data in
    which comparisons should be calculated. Functions used to calculated comparisons, and
    pairwise comparisons are performed separately in each of these groups. For example, if you
    wanted to compare each text with the mean of all texts in its condition, a \code{group}
    variable could identify and split by condition. Given multiple grouping variables,
    calculations will either be done in each split (if \code{all.levels = TRUE}; applied in
    sequence so that groups become smaller and smaller), or once after all splits are made (if
    \code{all.levels = FALSE}). This makes for 'one to many' comparisons with either calculated
    or preexisting standards (i.e., the profile of the current data, or a precalculated profile,
    respectively).}
  \item{Comparison ID}{When a comparison data is identified in \code{comp}, groups are assumed
    to apply to both \code{x} and \code{comp} (either both in \code{data}, or separately
    between \code{data} and \code{comp.data}, in which case \code{comp.group} may be needed if
    the same grouping variable have different names between \code{data} and \code{comp.data}).
    In this case, multiple grouping variables are combined into a single factor assumed to
    uniquely identify a comparison. This makes for 'one to many' comparisons with specific texts
    (as in the case of manipulated prompts or text-based conditions).}
  \item{Speaker ID}{If \code{comp} matches \code{'sequential'}, the last grouping variable
    entered is assumed to identify something like speakers (i.e., a factor with two or more
    levels and multiple observations per level). In the case of \code{comp = 'sequential'}, the
    data is assumed to be ordered (or ordered once sorted by \code{order} if specified). Any
    additional grouping variables before the last are treated as splitting groups. At least when
    treated sequentially, this sets up for probabilistic accommodation metrics.}
}
}

\references{
Babcock, M. J., Ta, V. P., & Ickes, W. (2014). Latent semantic similarity and language style
  matching in initial dyadic interactions. \emph{Journal of Language and Social Psychology, 33},
  78-88.

Ireland, M. E., & Pennebaker, J. W. (2010). Language style matching in writing: synchrony in
  essays, correspondence, and poetry. \emph{Journal of personality and social psychology, 99},
  549.

Landauer, T. K., & Dumais, S. T. (1997). A solution to Plato's problem: The latent semantic
  analysis theory of acquisition, induction, and representation of knowledge.
  \emph{Psychological review, 104}, 211.

Niederhoffer, K. G., & Pennebaker, J. W. (2002). Linguistic style matching in social interaction.
  \emph{Journal of Language and Social Psychology, 21}, 337-360.
}
