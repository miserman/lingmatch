<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Document-Term Matrix Weighting</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for lma_weight"><tr><td>lma_weight</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>Document-Term Matrix Weighting</h2>

<h3>Description</h3>

<p>Weight a document-term matrix.
</p>


<h3>Usage</h3>

<pre>
lma_weight(dtm, weight = "count", normalize = TRUE, wc.complete = TRUE,
  log.base = 10, alpha = 1, doc.only = FALSE, percent = FALSE)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>dtm</code></td>
<td>
<p>a matrix with words as column names.</p>
</td></tr>
<tr valign="top"><td><code>weight</code></td>
<td>
<p>a string referring at least partially to one (or a combination; see note) of the
available weighting methods:
</p>
<p><strong>Term weights</strong> (applied uniquely to each cell)
</p>

<table summary="Rd table">
<tr>
 <td style="text-align: left;">
    <code>binary</code> </td><td style="text-align: left;"> <code>(dtm &gt; 0) * 1</code> </td><td style="text-align: left;"> convert frequencies to 1s and 0s; remove
      differences in frequencies</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>log</code> </td><td style="text-align: left;"> <code>log(dtm + 1)</code> </td><td style="text-align: left;"> log of frequencies</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>sqrt</code> </td><td style="text-align: left;"> <code>sqrt(dtm)</code> </td><td style="text-align: left;"> square root of frequencies</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>count</code> </td><td style="text-align: left;"> <code>dtm</code> </td><td style="text-align: left;"> unaltered; sometimes called term frequencies (tf)</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>amplify</code> </td><td style="text-align: left;"> <code>dtm ^ alpha</code> </td><td style="text-align: left;"> amplify difference in frequencies</td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>

<p><strong>Document weights</strong> (applied by column)
</p>

<table summary="Rd table">
<tr>
 <td style="text-align: left;">
    <code>dflog</code> </td><td style="text-align: left;"> <code>log(colSums(dtm &gt; 0))</code> </td><td style="text-align: left;"> log of binary term sum</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>entropy</code> </td><td style="text-align: left;"> <code>1 - rowSums(x * log(x) / log(ncol(x)))</code> </td><td style="text-align: left;"> where
      <code>x = t(dtm) / colSums(dtm &gt; 0)</code>;
      entropy of term-conditional term distribution</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>ppois</code> </td><td style="text-align: left;"> <code>1 - ppois(alpha, colSums(dtm) / nrow(dtm))</code> </td><td style="text-align: left;"> Poisson-predicted
      term distribution</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>dpois</code> </td><td style="text-align: left;"> <code>1 - dpois(alpha, colSums(dtm) / nrow(dtm))</code> </td><td style="text-align: left;"> Poisson-predicted
      term density</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>dfmlog</code> </td><td style="text-align: left;"> <code>log(diag(x[max.col(t(x)),]))</code> </td><td style="text-align: left;"> log of maximum term
      frequency</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>dfmax</code> </td><td style="text-align: left;"> <code>diag(x[max.col(t(x)),])</code> </td><td style="text-align: left;"> maximum term frequency</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>df</code> </td><td style="text-align: left;"> <code>colSums(dtm &gt; 0)</code> </td><td style="text-align: left;"> sum of binary term occurance across documents</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>idf</code> </td><td style="text-align: left;"> <code>log(nrow(dtm) / colSums(dtm &gt; 0))</code> </td><td style="text-align: left;"> inverse document frequency</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>ridf</code> </td><td style="text-align: left;"> <code>idf - log(poisson)</code> </td><td style="text-align: left;"> residual inverse document frequency</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>normal</code> </td><td style="text-align: left;"> <code>1 / colSums(dtm ^ 2) ^ .5</code> </td><td style="text-align: left;"> normalized document frequency</td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>

<p>Alternatively, <code>'pmi'</code> or <code>'ppmi'</code> will apply a pointwise mutual information weighting
scheme (with <code>'ppmi'</code> setting negative values to 0).</p>
</td></tr>
<tr valign="top"><td><code>normalize</code></td>
<td>
<p>logical: if <code>FALSE</code>, the dtm is not divided by document word-count before
being weighted.</p>
</td></tr>
<tr valign="top"><td><code>wc.complete</code></td>
<td>
<p>if the dtm was made with <code>lma_dtm</code> (has a <code>'WC'</code>
attribute), word counts for
frequencies can be based on the raw count (default; <code>wc.complete = TRUE</code>). If
<code>wc.complete = FALSE</code>, or the dtm does not have a <code>'WC'</code> attribute,
<code>rowSums(dtm)</code> is used as word count.</p>
</td></tr>
<tr valign="top"><td><code>log.base</code></td>
<td>
<p>the base of logs, applied to any weight using <code>log</code>.
Default is 10.</p>
</td></tr>
<tr valign="top"><td><code>alpha</code></td>
<td>
<p>a scaling factor applied to document frequency as part of pointwise mutual
information weighting, or amplify's power (<code>dtm ^ alpha</code>, which defaults to 1.1), or the
specified quantile of the poisson distribution (<code>dpois(alpha,</code>
<code>colSums(x, na.rm = TRUE) /</code> <code>nrow(x))</code>).</p>
</td></tr>
<tr valign="top"><td><code>doc.only</code></td>
<td>
<p>logical: if <code>TRUE</code>, only document weights are returned (a single value for
each term).</p>
</td></tr>
<tr valign="top"><td><code>percent</code></td>
<td>
<p>logical; if <code>TRUE</code>, frequencies are multiplied by 100.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Term weights works to adjust differences in counts within documents, with differences meaning
increasingly more from <code>binary</code> to <code>log</code> to <code>sqrt</code> to <code>count</code> to <code>amplify</code>.
</p>
<p>Document weights work to treat words differently based on their between-document or overall frequency.
When term frequencies are constant, <code>dpois</code>, <code>idf</code>, <code>ridf</code>, and <code>normal</code> give
less common words increasingly more weight, and <code>ppois</code>, <code>df</code>, <code>dflog</code>, and
<code>entropy</code> give less common words increasingly less weight.
</p>
<p><code>weight</code> can either be a vector with two characters, corresponding to term weight and
document weight (e.g., <code>c('count', 'idf')</code>), or it can be a string with term and
document weights separated by any of <code>\*</code> (e.g., <code>'count \* idf'</code>).
<code>'tf'</code> is also acceptable for <code>'count'</code>, and <code>'tfidf'</code> will be parsed as
<code>c('count', 'idf')</code>, though this is a special case.
</p>
<p>For <code>weight</code>, term or document weights can be entered individually; term weights alone will
not apply any document weight, and document weights alone will apply a <code>'count'</code> term weight
(unless <code>doc.only = TRUE</code>, in which case a term-named vector of document weights is returned
instead of a weighted dtm).
</p>


<h3>Examples</h3>

<pre>
# visualize term and document weights

## term weights
term_weights = c('binary', 'log', 'sqrt', 'count', 'amplify')
Weighted = sapply(term_weights, function(w) lma_weight(1:20, w, FALSE))
if(require(splot)) splot(Weighted ~ 1:20, labx = 'Raw Count', lines = 'co')

## document weights
doc_weights = c('df', 'dflog', 'dfmax', 'dfmlog', 'idf', 'ridf',
  'normal', 'dpois', 'ppois', 'entropy')
weight_range = function(w, value = 1){
  m = diag(20)
  m[upper.tri(m, TRUE)] = if(is.numeric(value)) value else unlist(lapply(
    1:20, function(v) rep(if(value == 'inverted') 21 - v else v, v)
  ))
  lma_weight(m, w, FALSE, doc.only = TRUE)
}

if(require(splot)){
  category = rep(c('df', 'idf', 'normal', 'poisson', 'entropy'), c(4, 2, 1, 2, 1))
  op = list(
    laby = 'Relative (Scaled) Weight', labx = 'Document Frequency',
    leg = 'outside', colorby = list(quote(category), grade = TRUE),
    lines = 'connected', mv.scale = TRUE, note = FALSE
  )
  splot(
    sapply(doc_weights, weight_range) ~ 1:20,
    options = op, title = 'Same Term, Varying Document Frequencies',
    sud = 'All term frequencies are 1.'
  )
  splot(
    sapply(doc_weights, weight_range, value = 'sequence') ~ 1:20,
    options = op, title = 'Term as Document Frequencies',
    sud = 'Non-zero terms are the number of non-zero terms.'
  )
  splot(
    sapply(doc_weights, weight_range, value = 'inverted') ~ 1:20,
    options = op, title = 'Term Opposite of Document Frequencies',
    sud = 'Non-zero terms are the number of zero terms + 1.'
  )
}

</pre>


</body></html>
